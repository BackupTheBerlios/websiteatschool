<?php
# This file is part of Website@School, a Content Management System especially designed for schools.
# Copyright (C) 2008-2013 Ingenieursbureau PSD/Peter Fokker <peter@berestijn.nl>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License version 3 as published by
# the Free Software Foundation supplemented with the Additional Terms, as set
# forth in the License Agreement for Website@School (see /program/license.html).
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License
# for more details.
#
# You should have received a copy of the License Agreement for Website@School
# along with this program. If not, see http://websiteatschool.eu/license.html

/** /program/lib/database/mysql.class.php - access to mysql via database class
 *
 * This file is included from the poor mans database factory
 * in {@link databaselib.php}. It provides all necessary functionality
 * to use MySQL as the underlying database server.
 *
 * This file defines two classes: DatabaseMysql and DatabaseMysqlResult.
 * Typical usage would be:
 * <code>
 * $DB = new Database($table_prefix);          // once at program start
 * $DB->connect($host,$usr,$pwd,$dbname);      // once at program start
 *
 * $sql = "SELECT * FROM {$DB->prefix}foo";    // select all rows from table foo,
 * $DBResult = $DB->query($sql);
 * $all_rows = $DBResult->fetch_all_assoc()    // store everything in an array,
 * $DBResult->close();                         // and free the memory
 *
 * ...                                         // do something with $all_rows
 *
 * $DB->close();                               // once at program end
 * </code>
 *
 * @author Peter Fokker <peter@berestijn.nl>
 * @copyright Copyright (C) 2008-2013 Ingenieursbureau PSD/Peter Fokker
 * @license http://websiteatschool.eu/license.html GNU AGPLv3+Additional Terms
 * @package wascore
 * @version $Id: mysql.class.php,v 1.8 2013/06/11 11:26:07 pfokker Exp $
 */
if (!defined('WASENTRY')) { die('no entry'); }

/** this circumvents the sub-optimal implementation of booleans in MySQL */
define('SQL_FALSE',0);

/** this circumvents the sub-optimal implementation of booleans in MySQL */
define('SQL_TRUE',1);

/** MySQL database
 *
 * This implements access to the MySQL database.
 *
 */
class DatabaseMysql {
    /** @var string $db_type is the database type, always 'mysql' for this class */
    var $db_type;

    /** @var string $db_server is the name of the database server, e.g. 'localhost' or 'db.example.com:3306' */
    var $db_server;

    /** @var string $db_username is part of credentials for database access */
    var $db_username;

    /** @var string $db_password is part of credentials for database access */
    var $db_password;

    /** @var string $dn_name is the name of the database to use, e.g. 'was' */
    var $db_name;

    /** @var string $prefix is the table name prefix, e.g. 'was_' */
    var $prefix;

    /** @var resource $db_link is the database link identifier */
    var $db_link;

    /** @var string $db_version is the database version string. e.g. '5.1.32' or '4.0.23a' or FALSE if unavailable */
    var $db_version;

    /** @var integer $query_counter is the number of queries executed sofar */
    var $query_counter;

    /** @var integer $errno is the error number generated by the latest mysql command */
    var $errno;

    /** @var string $error is the error message generated by the latest mysql command */
    var $error;

    /** @var bool $debug if TRUE switch debugging on */
    var $debug;

    /** @var int $utf8_support is the level of UTF-8 support: 0 (none), 3 (limited), 4 (full, but with a quirky name) */
    var $utf8_support;

    /** initialise query counter and other variables, store the table prefix
     *
     * @param string $prefix table name prefix, e.g. 'was_'
     * @param bool $debug if TRUE extra information is displayed (handy for debugging the code)
     * @return void
     *
     */
    function DatabaseMysql($prefix,$debug=FALSE) {
        $this->prefix = $prefix;
        $this->query_counter = 0;
        $this->errno = 0;
        $this->error = '';
        $this->debug = $debug;
        $this->db_type = 'mysql';
        $this->db_version = FALSE;
        $this->utf8_support = 0;
    } // DatabaseMysql()


    /** connect to the database server and open the database
     *
     * this opens a connection to the database, perhaps sets some connection parameters and
     * subsequently selects the requested database. If anything goes wrong, FALSE is returned
     * and additional information can be retrieved from the variables $this->errno and $this->error.
     *
     * Note that for 4.1.x <= MySQL < 5.5.3 we use charset utf8 for the connection, whereas
     * for 5.5.3 and up we use the utf8mb4 charset which can handle UTF-8 with upto 4-byte sequences.
     *
     * @param string $db_server database server, e.g. 'localhost' or 'db.example.com:3306'
     * @param string $db_username part of credentials
     * @param string $db_password part of credentials
     * @param string $db_name database to use, e.g. 'was'
     * @return bool FALSE if failed, TRUE otherwise
     * @todo weigh pros and cons of persistent database connections, perhaps add as config option?
     */
    function connect($db_server,$db_username,$db_password,$db_name) {
        $this->db_server = $db_server;
        $this->db_username = $db_username;
        $this->db_password = $db_password;
        $this->db_name = $db_name;
        $this->db_link = mysql_connect($this->db_server,$this->db_username,$this->db_password);
        if (!$this->db_link) {
            $this->errno = mysql_errno();
            $this->error = mysql_error();
            return FALSE;
        }
        $this->utf8_support = $this->mysql_utf8_support($this->db_link);
        if ($this->utf8_support === FALSE) {
            $this->errno = mysql_errno();
            $this->error = mysql_error();
            return FALSE;
        }
        switch($this->utf8_support) {
        case 0: break;
        case 3: mysql_query("SET NAMES 'utf8' COLLATE 'utf8_unicode_ci'"); break;
        case 4: mysql_query("SET NAMES 'utf8mb4' COLLATE 'utf8mb4_unicode_ci'"); break;
        }
        if (!mysql_select_db($this->db_name,$this->db_link)) {
            $this->errno = mysql_errno();
            $this->error = mysql_error();
            return FALSE;
        }
        return TRUE;
    } // connect()


    /** close the connection to the database
     *
     * this closes the connection and resets the resource $this->db__link,
     * in order to prevent use of the connection after it is already closed.
     *
     * @return bool FALSE if failed, TRUE otherwise
     */
    function close() {
        $retval = mysql_close($this->db_link);
        $this->errno = mysql_errno();
        $this->error = mysql_error();
        $this->db_link = FALSE;
        $this->utf8_support = 0;
        $this->db_version = FALSE;
        return $retval;
    } // close()


    /** escape special characters in string
     *
     * this makes sure that dangerous characters like single quotes are properly escaped.
     * this routine has a special twist because of the limited support for UTF-8 in some
     * MySQL-versions. If support is limited ($this->utf_support equals 3), we strip any
     * 4-byte UTF-8 characters from the string and we replace those with the generic
     * substitution character U+FFFD (see als {@link mysql_utf8mb3}).
     *
     * The (bold) assumptions here are:
     *  1. the $unescaped_string is in fact proper UTF-8 (see {@link utf8_validate()}), and
     *  2. all strings that are headed for the database are funneled through this routine, always.
     *
     * @param string $unescaped_string the string to escape
     * @return string|bool FALSE on failure or the escaped string on success
     */
    function escape($unescaped_string) {
        $retval = mysql_real_escape_string(
            ($this->utf8_support == 3) ? $this->mysql_utf8mb3($unescaped_string) : $unescaped_string,
            $this->db_link);
        $this->errno = mysql_errno();
        $this->error = mysql_error();
        return $retval;
    } // escape()


    /** helper function for string concatenation in sql statements
     *
     * From http://troels.arvin.dk/db/rdbms/#functions-concat:
     *
     * SQL Standard: Core feature ID E021-07:
     * Concatenating two strings is done with the || operator:
     *
     *     string1 || string2
     *
     * If at least one operand is NULL, then the result is NULL.
     *
     * MySQL:
     * Badly breaks the standard by redefining || to mean OR.
     * Offers instead a function, CONCAT(string, string),
     * which accepts two or more arguments.
     *
     * In order to try and stay as database-independent as possible without
     * losing this concatenation feature, we have to resort to a
     * database-specific function. Aaargggghh!
     *
     * Typical use of this function:
     * <code>
     * ...
     * $sql = 'UPDATE {$DB->prefix}table '.
     *        'SET message = '.$DB->concat('message',"'".$DB->escape("addition to message\n")."'")." ".
     *        'WHERE table_id = '.$some_id;
     * $DB->exec($sql);
     * ...
     * </code>
     * and that's exactly the kind of hairy code I'd like to stay away from, because
     * of the necessary delicate balancing of quotes and the amount of thought it
     * requires to get a query right. Obviously it is much easier (and less quote-error prone
     * and almost elegant) to do something like this:
     * <code>
     *     $record = db_select('tablename','message',array('table_id' => $some_id));
     *     $value = $record['message'] . "addition to message\n";
     *     db_update('tablename',array('message' => $value),array('table_id' => $some_id));
     * </code>
     *
     * Note that 'Standard-SQL' would yield almost as much trouble with concatenation,
     * even if it were possible to use in MySQL, e.g.:
     * <code>
     * ...
     * $sql = 'UPDATE {$DB->prefix}table '.
     *        "SET message = message || '".$DB->escape("addition to message\n")."' ".
     *        'WHERE table_id = '.$some_id;
     * $DB->exec($sql);
     * ...
     * </code>
     * No matter what: this is ugly. The reason I still want to use this kind of
     * code is that (much) more expensive to use series of SELECT / UPDATE statements
     * with concatenation in PHP, not to mention the fact that using two separate
     * SQL-statements introduces race conditions, so there. Alas this is database specific.
     *
     * Note that some of the quote-hell can be dealt with via {@link db_escape_and_quote()}:
     * <code>
     * $sql = 'UPDATE {$DB->prefix}table '.
     *        'SET message = '.$DB->concat('message',db_escape_and_quote("addition to message\n")).' '.
     *        'WHERE table_id = '.$some_id;
     * $DB->exec($sql);
     * </code>
     *
     * @todo perhaps extend this function to accept more than 2 strings?
     * @param string $string1 contains a quoted/escaped string, a fieldname or other expression
     * @param string $string2 contains a quoted/escaped string, a fieldname or other expression
     * @return concatenation of input strings (database-specific)
     */
    function concat($string1,$string2) {
        // in PostgreSQL or Standard SQL it would simply be this:
        // return $string1.' || '.$string2;
        return 'CONCAT('.$string1.','.$string2.')';
    } // concat()


    /** execute an action query and return the number of affected rows
     *
     * this method should be used to exectute SQL-statements that do NOT
     * return a result set, use query() for that. This method works well
     * for INSERTs, DELETEs and UPDATEs. If there is an error this method
     * returns FALSE. Otherwise it returns the number of affected lines.
     * Note that there is a difference between 0 affected lines and FALSE.
     *
     * @param string $sql valid SQL statement
     * @return int|bool FALSE on failure or otherwise the # of affected rows 
     */
    function exec($sql) {
        if ($this->debug) { trigger_error('DEBUG: $DB->exec(): '.$sql); }
        $retval = mysql_query($sql,$this->db_link);
        ++$this->query_counter; // remember # of queries for performance metrics lateron
        if ($retval === FALSE) {
            $this->errno = mysql_errno();
            $this->error = mysql_error();
            return FALSE;
        } elseif ($retval === TRUE) {
            $affected_rows = mysql_affected_rows($this->db_link);
            if ($affected_rows == -1) {
                $this->errno = mysql_errno();
                $this->error = mysql_error();
                return FALSE;
            } else {
                $this->errno = 0;
                $this->error = '';
                return $affected_rows;
            }
        } else {
            $this->errno = -1;
            $this->error = 'query returned a result set but we were expecting an action query';
            return FALSE;
        }
        return FALSE;
    } // exec()


    /** retrieve the most recent automatically inserted id ('auto_increment')
     * 
     * this method returns the id that was automatically generated in the previous
     * INSERT-query or 0 if the previous query was not an INSERT query.
     *
     * Note: as per the MySQL manual this function returns an int and not a bigint.
     * If the auto_increment field is a bigint, this method returns an incorrect result.
     * There is a work-around (e.g. SELECT LAST_INSERT_ID()) but this is not the way
     * it works in Website@School; all id's are simple int's and not bigint's, so there
     * is no need to generate yet another query after every insert.
     *
     * Note that this method can be called with a table name and a field name.
     * This is a hook for future expansion; this MySQL-driver does not actually
     * use it. However, it is handy to always call this method with  table and 
     * field name to make adding a new database driver easier.
     *
     * @param string $table_name (optional) tablename (unused in MySQL)
     * @param string $field_name (optional) fieldname (unused in MySQL)
     * @return int|bool FALSE on failure, 0 if no id was generated or the id that was generated
     */
    function last_insert_id($table_name='',$field_name='') {
        // In PostgreSQL this could be the sequence name:
        // $sequence = $this->prefix.$table_name.'_'.$field_name.'_seq';
        $retval = mysql_insert_id($this->db_link);
        $this->errno = mysql_errno();
        $this->error = mysql_error();
        return $retval;
    } // last_insert_id()

    /** execute a select query and return a result set
     *
     * this method should be used to exectute SQL-statements that do
     * return a result set: SELECT, SHOW, EXPLAIN and DESCRIBE. Use exec()
     * for action queries . If there is an error this method returns FALSE.
     * Otherwise it returns a result set in the form of a DatabaseMysqlResult object.
     *
     * if parameters $limit and $offset are set the result set contains at most
     * $limit rows, starting at offset $offset. it is OK to specify just $limit;
     * $offset is taken into account only when $limit is specified too. Note that
     * different databases have a different syntax for limiting the number of returned
     * records. MySQL supports both 'LIMIT limit OFFSET offset' (which we use here) and
     * 'LIMIT offset,limit'.
     *
     * the LIMIT-clause is blindly appended to the SQL-statement; it is up to the caller
     * to decide wheter specifying a limit and an offset make sense or not.
     *
     * @param string $sql valid SQL statement
     * @param int $limit optional limitation of the number of records returned
     * @param int $offset optional number of records to skip; $offset = 0 means start with the first
     * @return object|bool FALSE on failure or otherwise a DatabaseMysqlResult object
     */
    function query($sql,$limit='',$offset='') {
        if (!empty($limit)) {
            $sql .= ' LIMIT '.intval($limit);
            if (!empty($offset)) {
                $sql .= ' OFFSET '.intval($offset);
            }
        }
        if ($this->debug) { trigger_error('DEBUG: $DB->query(): '.$sql); }
        $retval = mysql_query($sql,$this->db_link);
        ++$this->query_counter; // remember # of queries for performance metrics lateron
        if ($retval === FALSE) {
            $this->errno = mysql_errno();
            $this->error = mysql_error();
            return FALSE;
        } elseif ($retval === TRUE) {
            $this->errno = -1;
            $this->error = 'query appears to be an action query but we were expecting a result set';
            return FALSE;
	} else {
            $this->errno = 0;
            $this->error = '';
            return new DatabaseMysqlResult($retval);
        }
        return FALSE;
    } // query()


    /** unconditionally drop the specified table
     *
     * @param string $tablename the name of the table to drop (prefix will be added automatically)
     * @return int|bool FALSE on failure or otherwise the # of affected rows (always 0)
     */
    function drop_table($tablename) {
        $sql = 'DROP TABLE '.$this->prefix.$tablename;
        return $this->exec($sql);
    } // drop_table()


    /** see if the named table exists
     *
     * @param string $tablename name of the table to check (prefix will be added automatically)
     * @return bool TRUE if the table exists, FALSE otherwise
     */
    function table_exists($tablename) {
        $pattern = str_replace(array('_','%'),array('\_','\%'),$this->escape($this->prefix.$tablename));
        $sql = sprintf("SHOW TABLES LIKE '%s'",$pattern);
        $retval = mysql_query($sql);
        ++$this->query_counter; // remember # of queries for performance metrics lateron
        if ((is_resource($retval)) && (mysql_num_rows($retval))){
            mysql_free_result($retval);
            return TRUE;
        } else {
            return FALSE;
        }
    } // table_exists()


    /** create a table via a generic (non-MySQL-specific) table definition
     *
     * this executes a MySQL-specific CREATE TABLE statement based on a generic
     * table definition. The actual work is done in create_table_sql(), which makes
     * it possible to see the result of converting a generic definition to an actual
     * table; very handy while debugging.
     *
     * @param array $tabledef a generic table definition (not database-specific)
     * @return int|bool FALSE on failure or otherwise the # of affected rows (always 0)
     * @todo document correct link for documentation of generic table definition 'tabledefs.php'
     */
    function create_table($tabledef) {
        $sql = $this->create_table_sql($tabledef);
        if ($sql === FALSE) {
            return FALSE;
        }
        return $this->exec($sql);
    } // create_table()

    /** create the MySQL-specific SQL statement to create a table via a generic table definition
     *
     * this creates a MySQL-specific CREATE TABLE statement from a generic
     * table definition. See {@link tabledefs.php} for more information about
     * the format of this generic table definition.
     *
     * Note that this routine takes the level of UTF-8-support into account; for level 3
     * we use charset 'utf8' and for level 4 'utf8mb4' (see also {@link connect()}).
     *
     * The foreign key constraint is now capable of naming the constraints with a unique
     * (database wide) symbol. (Cures InnoDB-error 1005 (HY000) errno: 121). This symbol
     * is the prefixed tabledname followed by either the specified key name or a 1-based
     * integer uniquemaker per table. 
     *
     * @param array $tabledef a generic table definition (not database-specific)
     * @return string|bool FALSE on failure or otherwise a string with a CREATE TABLE statement
     * @todo document correct link for documentation of generic table definition 'tabledefs.php'
     * @todo find a way to deal with the enum values: where do we keep them? Or do we keep them at all?
     */
    function create_table_sql($tabledef) {
        $foreign_keys = 0;
        $sql = '';
        $sql .= 'CREATE TABLE '.$this->prefix.$tabledef['name']." (";
        $comma = '';
        foreach ($tabledef['fields'] as $fielddef) {
            $column_definition = $this->column_definition($fielddef);
            if ($column_definition === FALSE) {
                return FALSE;
            }
            $sql .= $comma."\n    ".$column_definition;
            $comma = ',';
        }
        foreach ($tabledef['keys'] as $keydef) {
            $sql .= ",\n    ";
            switch($keydef['type']) {
            case 'primary':
                // PRIMARY KEY (fieldlist)
                $sql .= sprintf('PRIMARY KEY (%s)',implode(',',$keydef['fields']));
                break;
            case 'index':
                // { UNIQUE | INDEX } [<name>] (fieldlist)
                $sql .= sprintf('%s %s (%s)',
                                (isset($keydef['unique']) && ($keydef['unique'])) ? 'UNIQUE' : 'INDEX',
                                (isset($keydef['name'])) ? $keydef['name'] : '',
                                implode(',',$keydef['fields']));
                break;
            case 'foreign':
                // CONSTRAINT <constraint> FOREIGN KEY [<name>] (<fielldlist>) REFERENCES reftable (<reffieldlist>)
                if (isset($keydef['name'])) {
                    $index_name = $keydef['name'];
                    $constraint = sprintf('%s%s_%s',$this->prefix,$tabledef['name'],$index_name);
                } else {
                    $index_name = '';
                    $constraint = sprintf('%s%s_fk%d',$this->prefix,$tabledef['name'],++$foreign_keys);
                }
                $sql .= sprintf('CONSTRAINT %s FOREIGN KEY %s (%s) REFERENCES %s%s (%s)',
                                $constraint,
                                $index_name,implode(',',$keydef['fields']),
                                $this->prefix,$keydef['reftable'],implode(',',$keydef['reffields']));
                break;
            default:
                trigger_error('internal error: unknown key type \''.$keydef['type'].'\'',E_USER_ERROR);
                return FALSE;
                break;
            }
        }
        $sql .= "\n)";
        switch($this->utf8_support) {
        case 3: $sql .= ' DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci'; break;
        case 4: $sql .= ' DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci'; break;
        }
        if (isset($tabledef['comment'])) {
            $sql .= ' COMMENT = \''.$this->escape($tabledef['comment']).'\'';
        }
        $sql .= "\n";
        return $sql;
    } // create_table_sql()


    /** convert a fielddef array to a MySQL specific column definition
     *
     * this creates a MySQL specific column definition based on a generic field
     * description. The following keywords are recognised:
     *  - name: the name of the field (required)
     *  - type: the generic type of the field (see table below for supported types) (required)
     *  - length: the size of a numeric field or the length of a textual field
     *  - decimals: the number of decimals in real numbers (implies length)
     *  - unsigned: used for numeric fields that don't need negative values (see note 5 below)
     *  - notnull: if true, the field is not allowed/able to contain the NULL value
     *  - default: the default value for the field
     *  - enum_values: an array with allowable values for the enum field
     *  - comment: a string that can be used to document the field definition
     *
     * The generic field types are mapped to actual MySQL data types via a lookup table.
     * Most types have a number of  boolean flags which indicate how the field definition
     * must be interpreted. Entries with an empty type are considered special cases.
     *
     *  - len = 1: look for a length parameter and use it if it is defined.
     *  - dec = 1: look for a decimals parameter and use it if it is defined. Implies len.
     *  - unsigned = 1: look for an unsigned parameter and use it if it is defined and true (see note 5 below).
     *  - default = 1: look for a default parameter, and use it if it is defined.
     *  - quote = 1: if a default is allowed AND defined, use single quotes + escaped string.
     *
     * Note 1: a 1 in the table means that the field type _allows_ the corresponding parameter,
     * and 0 means that this parameter is NOT allowed. It doesn't say anything about parameters
     * being _required_ (e.g. a varchar must have a length). It is the responsability of the
     * author of the field definition to provide all necessary parameters.
     *
     * Note 2: enum_values are not used at this time; an enum-field simply maps to a
     * varchar field and that's it. Adding the enum_values to a data definition does help
     * to document the purpose of the field. The reason for not (yet) implementing enums
     * in full is the issues associated with the translations in the UI. Furthermore, using
     * native enums in MySQL is a royal PITA. For now the application should know what it is
     * doing when using and updating enums in a table.
     *
     * Note 3: at this time it is not possible to set the default value of a text-type field
     * to the string consisting of the letters N, U, L and L: that caseinsensitive string is
     * always interpreted as the NULL-value in the database, ie. it yields "DEFAULT NULL" and
     * not "DEFAULT 'NULL'" or "DEFAULT 'Null'" or "DEFAULT 'null'".
     *
     * Note 4: even though comments may or may not be stored in the MySQL database, the corresponding
     * COMMENT-clauses are generated, if only for documentation/debugging purposes. These
     * clauses are correctly parsed by MySQL but they are subsequently discarded in old MySQL-versions.
     *
     * Note 5:
     * As of version 2009051401 (0.0.5) the parameter 'unsigned' is deprecated.
     * This is because even though MySQL implements an unsigned attribute for numeric fields,
     * other RDBMSs might not. Therefore we stay away from this MySQL-specific construct as
     * much as possible. Also, the translation from the 'serial' fieldrtype no longer adds
     * the unsigned attribute to the actual MySQL definition.
     *
     * @param array an array that describes a field in a generic way
     * @return bool|string FALSE on failure or a MySQL-specific string defining the column
     * @todo should we allow both int and integer?
     * @todo 'enum' type equivalent with varchar, enum_values[] array is not used at all, only as a form of documentation
     */
    function column_definition($fielddef) {
        static $type_map = array(
            'short'    => array('type' => 'SMALLINT', 'len' => 1,'dec' => 0,'unsigned' => 1,'default' => 1,'quote' => 0),
            'int'      => array('type' => 'INT',      'len' => 1,'dec' => 0,'unsigned' => 1,'default' => 1,'quote' => 0),
            'long'     => array('type' => 'BIGINT',   'len' => 1,'dec' => 0,'unsigned' => 1,'default' => 1,'quote' => 0),
            'float'    => array('type' => 'FLOAT',    'len' => 1,'dec' => 1,'unsigned' => 1,'default' => 1,'quote' => 0),
            'double'   => array('type' => 'DOUBLE',   'len' => 1,'dec' => 1,'unsigned' => 1,'default' => 1,'quote' => 0),
            'decimal'  => array('type' => 'DECIMAL',  'len' => 1,'dec' => 1,'unsigned' => 1,'default' => 1,'quote' => 0),
            'number'   => array('type' => 'DECIMAL',  'len' => 1,'dec' => 1,'unsigned' => 1,'default' => 1,'quote' => 0),
            'varchar'  => array('type' => 'VARCHAR',  'len' => 1,'dec' => 0,'unsigned' => 0,'default' => 1,'quote' => 1),
            'enum'     => array('type' => 'VARCHAR',  'len' => 1,'dec' => 0,'unsigned' => 0,'default' => 1,'quote' => 1),
            'char'     => array('type' => 'CHAR',     'len' => 1,'dec' => 0,'unsigned' => 0,'default' => 1,'quote' => 1),
            'text'     => array('type' => 'TEXT',     'len' => 0,'dec' => 0,'unsigned' => 0,'default' => 0,'quote' => 0),
            'longtext' => array('type' => 'LONGTEXT', 'len' => 0,'dec' => 0,'unsigned' => 0,'default' => 0,'quote' => 0),
            'blob'     => array('type' => 'BLOB',     'len' => 0,'dec' => 0,'unsigned' => 0,'default' => 0,'quote' => 0),
            'longblob' => array('type' => 'LONGBLOB', 'len' => 0,'dec' => 0,'unsigned' => 0,'default' => 0,'quote' => 0),
            'date'     => array('type' => 'DATE',     'len' => 0,'dec' => 0,'unsigned' => 0,'default' => 1,'quote' => 1),
            'time'     => array('type' => 'TIME',     'len' => 0,'dec' => 0,'unsigned' => 0,'default' => 1,'quote' => 1),
            'datetime' => array('type' => 'DATETIME', 'len' => 0,'dec' => 0,'unsigned' => 0,'default' => 1,'quote' => 1),
            'timestamp'=> array('type' => 'TIMESTAMP','len' => 0,'dec' => 0,'unsigned' => 0,'default' => 1,'quote' => 1),
            'serial'   => array('type' => ''), // see also note 5 above.
            'bool'     => array('type' => '')
        );

        if (!isset($type_map[$fielddef['type']])) {
            trigger_error('internal error: unknown field type \''.$fielddef['type'].'\'',E_USER_ERROR);
            return FALSE;
        }
        $column_def = $fielddef['name'].' '; // collect the output, start with the field's name

        $field = $type_map[$fielddef['type']];
        if (empty($field['type'])) { // special case, e.g. bool or serial
            switch ($fielddef['type']) {
            case 'serial':
                $column_def .= 'INT NOT NULL AUTO_INCREMENT UNIQUE'; // Note: no implied PRIMARY KEY
                break;
            case 'bool':
                $column_def .= 'TINYINT(1)';
                if (isset($fielddef['notnull']) && ($fielddef['notnull'])) {
                    $column_def .= " NOT NULL";
                }
                if (isset($fielddef['default'])) {
                    $column_def .= ' DEFAULT ';
                    if (is_null($fielddef['default']) || (strcasecmp($fielddef['default'],'null') == 0)) {
                        $column_def .= 'NULL';
                    } else {
                         $column_def .= ($fielddef['default']) ? SQL_TRUE : SQL_FALSE;
                    }
                }
                break;
            default:
                trigger_error('internal error: \''.$fielddef['name'].'\' is no special case',E_USER_ERROR);
                return FALSE;
                break;
            }
        } else {
            $column_def .= $field['type'];
            /* if this field is allowed to have a length, maybe pickup the specified length and optional decimals */
            if ($field['len']) {
                if (isset($fielddef['length'])) {
                    if ((($field['dec'])) && (isset($fielddef['decimals']))) {
                        $column_def .= '('.$fielddef['length'].','.$fielddef['decimals'].')';
                    } else {
                        $column_def .= '('.$fielddef['length'].')';
                    }
                }
            }
            if ($field['unsigned']) {
                // See note 5 above: 'unsigned' is deprecated.
                if (isset($fielddef['unsigned']) && ($fielddef['unsigned'])) {
                    $column_def .= " UNSIGNED";
                }
            }
            if (isset($fielddef['notnull']) && ($fielddef['notnull'])) {
                $column_def .= " NOT NULL";
            }
            if ($field['default']) {
                if (isset($fielddef['default'])) {
                    if (utf8_strcasecmp($fielddef['default'],'null') == 0) { // see the note above
                        $column_def .= ' DEFAULT NULL';
                    } elseif ($field['quote']) {
                        $column_def .= ' DEFAULT \''.$this->escape($fielddef['default']).'\'';
                    } else {
                        $column_def .= ' DEFAULT '.$fielddef['default'];
                    }
                }
            }
        }
        if (isset($fielddef['comment'])) {
            $column_def .= ' COMMENT \''.$this->escape($fielddef['comment']).'\'';
        }
        return $column_def;
    } // column_definition()


    /** make a text dump of our tables in the database suitable for backup purposes
     *
     * This creates a text dump of the selected tables in parameter $data. If $tables
     * is empty we dump all the tables in the database that start with 'our' prefix
     * (there could be other websites using the same table with another prefix, we
     * won't dump those). If $tables is an array, it is assumed to be an array with
     * table names without our prefix. In this case we will prepend the prefix.
     * If parameter $drop is TRUE, we add code to drop the table from the database
     * (if it exists) before we recreate it.
     *
     * If there were no errors, we return TRUE (and $data contains the dump).
     * If errors were encountered, we return FALSE and $this->errno and $this->error can tell
     * the caller what happened. If there were errors, $data is undefined.
     *
     * Strategy is as follows. First we make a valid list of tables to dump,  either by
     * asking the database for a list of tables LIKE "{$prefix}%" or by manipulating and
     * validating the array $tables that was provided by the caller.
     *
     * Subsequently we let the database generate a CREATE TABLE statement and then we
     * step through the data (if any) and add it to $data.
     *
     * Note
     * MySQL is quite liberal in what it accepts as field values. However, I try to generate
     * INSERT INTO-statements as clean as possible by NOT quoting numeric values. HTH.
     * It still is a MySQL-specific dump, though. You cannot simply use the result 'as-is' to
     * migrate to another database.
     *
     * @param string &$data receives the dump of the tables
     * @param bool $drop if TRUE add code to drop the table before the data definition
     * @param mixed $tables array with names of tables to dump, empty (string, array) means all our tables
     * @return bool TRUE on success and data in &$dump, FALSE on failure and &$dump undefined
     */
    function dump(&$data,$drop=TRUE,$tables='') {
        global $CFG,$USER;

        // 0 -- initialise
        $tables_to_dump = array();
        $data = sprintf("# Website@School Database Backup %s (%s, v%s)\n",WAS_RELEASE,WAS_RELEASE_DATE,WAS_VERSION).
                sprintf("# Extracted from `%s` on %s by %s\n",$CFG->db_name,strftime('%Y-%m-%d %T %z'),$USER->username).
                sprintf("# Database: MySQL %s\n",($this->db_version === FALSE) ? 'unknown' : $this->db_version).
                sprintf("# Website: %s\n",$CFG->www)."\n";

        // 1 -- which tables need to be dumped? 
        if ((!is_array($tables)) || (empty($tables))) {
            // 1A -- use all 'our' tables
            $pattern = str_replace(array('_','%'),array('\_','\%'),$this->escape($this->prefix)).'%';
            $sql = sprintf("SHOW TABLES LIKE '%s'",$pattern);
            ++$this->query_counter; // remember # of queries for performance metrics lateron
            if ((($result = mysql_query($sql)) === FALSE) || (($num_rows = mysql_num_rows($result)) === FALSE)) {
                $this->errno = mysql_errno();
                $this->error = mysql_error();
                mysql_free_result($result); // never mind that $result might be FALSE, we're outta here anyway
                return FALSE;
            }
            while ($record = mysql_fetch_row($result)) {
                $tables_to_dump[] = $record[0];
            }
            mysql_free_result($result);
        } else {
            // 1B - use the list provided as a start
            $tables_to_dump = array();
            foreach($tables as $table) {
                // I know this is expensive, but I just want to make sure _before_ we start the main loop
                if ($this->table_exists($table)) {
                    $tables_to_dump[] = $this->prefix.$table;
                }
            }
        }
        // 1C -- any tables to do at all?
        if (sizeof($tables_to_dump) < 1) {
            $data .= "\n".
                     "# No tables found\n\n".
                     "# end of Website@School Database Backup\n";
            return TRUE;
        }

        // 2 -- for all tables do { print drop table; print tabledef; print table data; }
        //
        // the MySQL-field types in this list do not need quotes
        $no_quotes = array('tinyint','smallint','mediumint','bigint','int','float','double','decimal');
        foreach($tables_to_dump as $table) {

            // 2A -- maybe drop table
            $data .= sprintf("%sDROP TABLE IF EXISTS `%s`;\n",($drop) ? '' : '# ',$table);

            // 2B -- always create table
            $sql = sprintf('SHOW CREATE TABLE `%s`',$table);
            ++$this->query_counter; // remember # of queries for performance metrics lateron
            if ((($result = mysql_query($sql)) === FALSE) || (($record = mysql_fetch_row($result)) === FALSE)) {
                $this->errno = mysql_errno();
                $this->error = mysql_error();
                mysql_free_result($result);
                return FALSE;
            }
            $data .= $record[1].";\n\n";

            // 2C -- fiddle with quoted and unquoted fields by looking at column definitions
            $sql = 'SHOW COLUMNS FROM '.$table;
            ++$this->query_counter; // remember # of queries for performance metrics lateron
            if (($result = mysql_query($sql)) === FALSE) {
                $this->errno = mysql_errno();
                $this->error = mysql_error();
                return FALSE;
            }
            // 2D -- the column types in the list $no quotes don't need quotes, all others do
            $needs_quotes = array();
            while ($record = mysql_fetch_row($result)) {
                $vtype = explode("(",$record[1]);
                $needs_quotes[$record[0]] = (in_array($vtype[0],$no_quotes)) ? FALSE : TRUE;
            }

            // 3 -- fetch data from this table
            $sql = 'SELECT * FROM '.$table;
            ++$this->query_counter; // remember # of queries for performance metrics lateron
            if ((($result = mysql_query($sql)) === FALSE) || (($num_rows = mysql_num_rows($result)) === FALSE)) {
                $this->errno = mysql_errno();
                $this->error = mysql_error();
                mysql_free_result($result);
                return FALSE;
            }
            // 3A -- continue with next table if no data at all
            $data .= sprintf("# Table `%s` contains %d record(s)\n",$table,$num_rows);
            if ($num_rows < 1) {
                $data .= "\n"; // 'pour le visage'....
                continue;
            }

            // 3B -- step through the data, one record at a time
            $insert = sprintf("INSERT INTO `%s` VALUES(",$table);
            while ($record = mysql_fetch_assoc($result)) {
                $data .= $insert;
                $glue = '';
                foreach($record as $field => $value) {
                    $data .= $glue;
                    if (is_null($value)) {
                        $data .= 'NULL';
                    } else {
                        $data .= ($needs_quotes[$field]) ? "'".addslashes($value)."'" : $value;
                    }
                    if ($glue == '') { $glue = ','; }
                }
                $data .= ");\n";
            }
            $data .= "\n";
            mysql_free_result($result);
        }
        $data .= sprintf("# end of Website@School Database Backup %s\n",strftime('%Y-%m-%d %T %z'));
        return TRUE;
    } // dump()


    /** determine the level of UTF-8 support based on MySQL-server version
     *
     * MySQL support for UTF-8 was non-existent before 4.1.x and limited
     * until 5.5.3. In this context 'limited' means: only the Basic
     * Multilingual Plane (U+0000 ... U+FFFF) is supported, i.e. a maximum
     * of 3-byte sequences per character.
     *
     * As of 5.5.3 the full UTF-8 specification according to RFC 3629 is implemented. MySQL now
     * has 'invented' yet another proprietary name for this character set: 'utf8mb4' (WTF?),
     * and introduces the alias 'utf8mb3' for the pre 5.5.3 limited support for 'utf8' (WTF??),
     * hinting that the meaning of 'utf8' may change in future versions to indicate 'utf8mb4' (WTF???).
     * IM(NS)HO this is yet another reason to go looking for a decent replacement for MySQL. YMMV.
     *
     * This routine returns exactly one of the values below (based on the server version).
     *
     *  - 0: there is no UTF-8 support available in this server
     *  - 3: the limited 3-byte sequences are supported
     *  - 4: full support for 4-byte sequences available, but using the stupid ad-hoc name 'utf8mb4'
     *
     * or the value FALSE if version information could not be obtained.
     *
     * As a side effect, we record the server version information in $this->db_version (which is
     * handy when creating a backup and also for debugging purposes).
     *
     * @param resource $db_link the MySQL connection
     * @return int|bool support level: either 0 (none), 3 (limited), 4 (full, but with a quirky name) or FALSE on error
     */
    function mysql_utf8_support($db_link) {
        if (($this->db_version = mysql_get_server_info($db_link)) === FALSE) {
            return FALSE;
        }
        $vrp = explode('.',$this->db_version);
        $v = (isset($vrp[0])) ? intval($vrp[0]) : 0;
        $r = (isset($vrp[1])) ? intval($vrp[1]) : 0;
        $p = (isset($vrp[2])) ? intval($vrp[2]) : 0;
        if (($v < 4) || (($v == 4) && ($r < 1))) { // None before 4.1.x
            return 0;
        } elseif (($v == 4) || (($v == 5) && ($r < 5)) || (($v == 5) && ($r == 5) && ($p < 3))) { // Limited before 5.5.3
            return 3;
        } else { // Full as of 5.5.3
            return 4;
        }
    } // mysql_utf8_support()


    /** massage string to contain only 3-byte UTF8-sequences
     *
     * this replaces an otherwise perfectly valid 4-byte UTF-8 sequence
     * in $utf8str with a 3-byte UTF-8 sequence equivalent with the
     * Unicode replacement character U+FFFD.
     *
     * The effect is that it leaves a hint that there used to be some character
     * instead of silently discarding 4-byte sequences which MySQL does.
     *
     * @param string $utf8str valid UTF-8 encoded string
     * @return string UTF-8 string with all 4-byte sequences replaced
     */
    function mysql_utf8mb3($utf8str) {
        $search = array('/\\xF0[\\x90-\\xBF][\\x80-\\xBF]{2}/', // 4-byte excluding overlongs
                        '/[\\xF1-\\xF3][\\x80-\\xBF]{3}/',      // 4-byte planes 4-15
                        '/\\xF4[\\x80-\\x8F][\\x80-\\xBF]{2}/');// 4-byte plane 16
        $replace = "\xEF\xBF\xBD"; // UTF-8 encoded Unicode replacement character U+FFFD
        return preg_replace($search,$replace,$utf8str);
    } // mysql_utf8mb3()

} // end of class DatabaseMysql


/** MySQL database result
 *
 * This implements access to database result sets
 *
 */
class DatabaseMysqlResult {
    /** @var resource the resource associated with the result set */
    var $result;

    /** @var integer the error number generated by the latest mysql command */
    var $errno;

    /** @var string the error message generated by the latest mysql command */
    var $error;

    /** @var integer the number of rows in the result set */
    var $num_rows;

    /** constructor
     * @param resource the resource associated with the result set
     * @return void
     */
    function DatabaseMysqlResult($result) {
        $this->result = $result;
        $this->num_rows = mysql_num_rows($result);
        $this->errno = mysql_errno();
        $this->error = mysql_error();
    } // DatabaseMysqlResult()


    /** free the memory associated with the result set
     *
     * @return bool FALSE on failure, TRUE otherwise
     */
    function close() {
        $retval = mysql_free_result($this->result);
        $this->errno = mysql_errno();
        $this->error = mysql_error();
        return $retval;
    } // close()


    /** fetch the next result row as a 0-based enumerated array
     *
     * @return array|bool FALSE if there are no more rows, or a 0-based array corresponding to a row
     */
    function fetch_row() {
        return mysql_fetch_row($this->result);
    } // fetch_row()


    /** fetch the next result row as a associative array
     *
     * @return array|bool FALSE if there are no more rows, or an associative array corresponding to a row
     */
    function fetch_row_assoc() {
        return mysql_fetch_assoc($this->result);
    } // fetch_row_assoc()


    /** fetch all rows as a 0-based array of 0-based enumerated arrays
     *
     * @return array an array containing 0 or more result rows as 0-based arrays
     */
    function fetch_all() {
        $all_rows = array();
        for ($i = 0; $i < $this->num_rows; ++$i) {
            $all_rows[$i] = $this->fetch_row();
        }
        return $all_rows;
    } // fetch_all()


    /** fetch all rows as an array (0-based or keyed) of associative arrays
     *
     * This returns an array of assoc arrays (one per record).
     * If $key is not empty, we use the contents of the field as the array key,
     * otherwise we simply use a 0-based numeric key. By specifying a single
     * unique field (e.g. the primary key) all records in the array can be
     * accessed via their unique value.
     *
     * @param string $keyfield field to use as the key in the returned array or empty for 0-based numeric array key
     * @return array an array containing 0 or more result rows as associative arrays
     */
    function fetch_all_assoc($keyfield='') {
        $all_rows = array();
        if (empty($keyfield)) {
            for ($i = 0; $i < $this->num_rows; ++$i) {
                $all_rows[$i] = $this->fetch_row_assoc();
            }
        } else {
            for ($i = 0; $i < $this->num_rows; ++$i) {
                $record = $this->fetch_row_assoc();
                $k = (isset($record[$keyfield])) ? $record[$keyfield] : $i;
                $all_rows[$k] = $record;
            }
        }

        return $all_rows;
    } // fetch_all_assoc()

} // end of class DatabaseMysqlResult

?>